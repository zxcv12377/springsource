서버단 작성
 1) Spring framework : 웹 개발할 때 주로 사용(과거) / 다수의 설정 작업이 필요 / 
 2) Spring Boot : Spring Framework를 간편화한 버전

프로젝트 생성
 1. 빌드 툴 설정
 build : 프로젝트 생성, 라이브러리 설정, 코드작업, 컴파일, 테스트, 패키지작성, 배포
  1) gradle : text 기반, 후발주자(maven 개선)
  2) maven : xml 기반, 

 2. Spring boot version 선택 : 3.4.4 
 3. 언어 선택
 4. 패키지명 : com.example.demo (자유롭게 지정 가능)
 5. 패키징 타입 : jar(자바 압축파일), war(자바 웹 압축파일 -> jsp 사용시)
 6. 자바 버전 선택 : 부트 버전에 따라 선택이 달라질 수 있다
 7. 필요 라이브러리 선택 : 
  - Spring Web, dev tools, thymleaf, lombok (기본)

 화면(front)단 작성 : html + css + javascript + java
  1) jsp 활용 : *.jsp
     html 코드 + java 코드 동식 작성
     spring boot에서 사용하기 위해서는 설정 작업 필요

  2) 특정 템플릿 엔진 활용 : *.html
     thymeleaf, mustache, groovy, freemaker, velocity

스프링 주요 개념
 1) IoC(Inversion of Control) : 메소드나 객체의 호출 작업을 개발자가 결정하는 것이 아니라 외부(spring container)에서 결정(제어의 역전)

    [자바에서는]
    class A{}
    class B{
        A obj = new A();
    }

    [스프링에서는]
    컨테이너는 어느 객체를 생성할 것인지 알아야 함 => 어노테이션(@)으로 알려주기
    - 컨테이너가 생성한 객체 : bean
    - 싱글톤 방식(객체는 하나만 생성)으로 객체 생성
    - ex) @Controller, @Service, @Component

 2) 경로 임의로 생성
    http://localhost:8080/ ==> Controller 파일의 메소드와 매핑

    uri 설계
    ex) 게시판 개발
    게시글 작성 : /board/create
    게시글 목록 : /board/list
    게시글 조회 : /board/read
    게시글 수정 : /board/update

@RequestMapping("/board")
public class boardController {

    @GetMapping("/create")
    public String method(){
        return "info";
    }

    @GetMapping("/update")
    public void method(){
    }
}
    String
    http://localhost:8080/board/create 브라우저요청 => 컨트롤러 응답 
    => templates 찾기(/templates / return 값 찾기) => templates / info.html 작성

    void
    http://localhost:8080/board/update 브라우저요청 => 컨트롤러 응답 
    => templates 찾기(/templates / board / update) => templates / board / update.html 작성


3) 내장 서버 : Tomcat(설치 후 사용 - 스프링부트를 사용한다면 내장되어 있음)

  http://localhost:8080/ : Tomcat 서버 구동시의 기본 경로

  브라우저를 통해 http, https 프로토콜에 응답하는 서버 : SW 웹서버(Apache, NgineX)
  WAS(Web Application Server) : 웹서버 + 자바해석 => Tomcat

4) 오류발생
 404 : 컨트롤러 경로 확인
 405 : 컨트롤러 경로 + 매핑방식 확인

5) 사용자 입력값 가져오기
  (1) 변수 이용 : 타입 지정 가능, 변수명은 form 요소의 이름과 일치(Model.addAttribute("key", value))
  (2) 커맨드(DTO) 객체 이용 : 타입 지정 가능, 변수명은 form 요소의 이름과 일치
                              커맨드 객체 사용시 장점은 template 페이지까지 입력값이 유지됨
  (3) HttpServletRequest 이용 : 최근에는 거의 사장됨

6) @ModelAttribute
  - 별칭
  - model.addAttribute("num1", num1) == @ModelAttribute("num1") : template 페이지에서 값을 유지하고 싶다면

7) RedirectAttributes : 컨트롤러에서 움직이는 방식이 redirect일 때 사용 / 움직이면서 특정 값을 가지고 가고 싶을때 사용
  - rttr.addAttribute("userid", "10"); ?userid = 10 => 템플릿 ${param.userid}
  - rttr.addFlashAttribute("password", "12"); session 객체에 담는것과 같은 방식${password}

8) 데이터 유지하기
  - login.html 입력값 ==> 컨트롤러 ==> logout.html 입력값을 유지하고 싶다면?
    - forward 방식 : @ModelAttribute, Model, 커맨드 객체
    - redirect 방식 : RedirectAttributes 이용
  - login.html 입력값 ==> 컨트롤러 ==> 모든 페이지에서 입력값을 유지하고 싶다면?
    - Session : 값을 서버 쪽에 저장함(객체 형태로 담는 것도가능)
                HttpSession 을 이용해 저장 => 필요 없는 경우 제거 or 현재 세션이 유지되고 있는 브라우저를 닫으면 종료
    - 쿠키 : 값을 클라이언트 브라우저로 전송 후 저장
  - login.html 입력값 ==> 컨트롤러 ==> 다른 페이지에서 입력값 소멸? 
    - 컨트롤러에서 변수로 값을 받아오는 경우
 